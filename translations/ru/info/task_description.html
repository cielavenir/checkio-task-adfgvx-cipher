<p>

    <a href="http://en.wikipedia.org/wiki/ADFGVX_cipher">ADFGVX шифр</a>
    был полевым военным шифром, который использовался Немецкой Армией на западном фронте в Первую
    Мировую Войну.

    ADFGVX был по сути усовершенствованием шифра ADFGX.
    Изобретенный полковником Фрицом Небелем и представленном в марте 1918 года, шифр был
    перестановочным шифром совмещенный с изменённым квадратом Полибия со смещением в один столбец.
    Шифр назван согласно 6 используемых букв в шифровке:
    A, D, F, G, V и X.
    Эти буквы выбраны специально потому что они наиболее отличаются друг от друга, при использовании
    азбуки Морзе и тем самым свести вероятность ошибки к минимуму.
</p>


<p>
    Давайте посмотрим, как работает шифр на примере. Наше сообщение -- "I am going."
    Первым делом "очистим" его и переработаем: "iamgoing".
    Оно должно содержать только цифры и латинские буквы в нижнем регистре.
    Все остальные символы удаляются. Затем заполним "adfgvx" таблицу нашим секретным алфавитом
    "dhxmu4p3j6aoibzv9w1n70qkfslyc8tr5e2g".
</p>

<pre>
\  A D F G V X
 \------------
A| d h x m u 4
D| p 3 j 6 a o
F| i b z v 9 w
G| 1 n 7 0 q k
V| f s l y c 8
X| t r 5 e 2 g

</pre>

<p>
    Используя этот квадрат, сообщение переводится в координатную форму (строка-столбец):
</p>
<pre>
i  a  m  g  o  i  n  g
FA DV AG XX DX FA GD XX

</pre>

<p>
    Затем новая таблица делается с помощью слова-ключа в заголовке.
    Пусть это будет 'cipher'.

    <strong>Если в ключе есть повторяющиеся буквы, то остается только первая из них.</strong>
    Так, "checkio" станет "chekio".
</p>
<pre>
c i p h e r
-----------
F A D V A G
X X D X F A
G D X X

</pre>

<p>
    Столбцы упорядочиваются в алфавитном порядке на основе ключа и таблица приобретает новый вид.
</p>
<pre>
c e h i p r
-----------
F A V A D G
X F X X D A
G   X D X

</pre>
<p>
    Затем читаем по столбцам  и получаем результат "FXGAFVXXAXDDDXGA".
</p>

<p>
    Вы должны написать две функции для шифрования и расшифровки - "encode" и "decode".
    Каждая функция принимает сообщение (шифрованное или открытое),
    секретный алфавит и ключ.
    Функция "encode" зашифровывает сообщение.
    А "decode" соответственно расшифровывает (конечно в "очищенную" форму).
</p>

<p>
    <strong>Входные данные: </strong>
    Три аргумента. Сообщение, секретный алфавит и ключ, как строки.
</p>

<p>
    <strong>Выходные данные: </strong> Обработанное сообщение, как строка.
</p>


<div class="for_info_only">
    <p>
        <strong>Примеры:</strong>
    </p>
    <pre class="brush: python">
encode('I am going.', 'dhxmu4p3j6aoibzv9w1n70qkfslyc8tr5e2g','cipher') == 'FXGAFVXXAXDDDXGA'
decode('FXGAFVXXAXDDDXGA', 'dhxmu4p3j6aoibzv9w1n70qkfslyc8tr5e2g','cipher') == 'iamgoing'
    </pre>
</div>

<p class="for_info_only">
    <strong>Как это используется: </strong>
    В это задаче вы поработаете с различными структурами данных в применении к позиционным шифрам.
    Эти шифры могут быть удобны если у вас нет компьютера под рукой для более сложных криптографических трюков.
</p>

<p>
    <strong>Предусловия:</strong><br>
    re.match("[a-z]+\Z", keyword)<br>
    re.match("[a-z0-9]+\Z", secret_alphabet)<br>
    len(set(secret_alphabet)) == len(secret_alphabet)<br>
</p>